// provider/feature/tailscale-provider.ts - Tailscale Feature Provider
//
// Implements FeatureProvider<TailscaleConfig, TailscaleState>.
// Attaches Tailscale VPN to running instances via SSE command + heartbeat poll.
// Device records stored in the objects table (type='tailscale_device').
//
// Spec ref: §8.4 (Feature Provider Interface).
// Related task: #PROV-05

import type {
  FeatureProvider,
  FeatureCapabilities,
  FeatureReconcileContext,
  ReconcileResult,
} from "../types";
import {
  TailscaleApiClient,
  TailscaleApiError,
  type TailscaleDevice,
} from "./tailscale-api";
import {
  queryOne,
  queryMany,
  createBlob,
  createObject,
  addObjectTag,
  deleteObject,
} from "../../material/db";
import { getInstance, updateInstance } from "../../material/db";
import { commandBus } from "../../events/command-bus";

// =============================================================================
// Types
// =============================================================================

export interface TailscaleConfig {
  /** Auth key pre-generated by caller; if absent, provider creates one. */
  authKey?: string;
  /**
   * Desired Tailscale hostname. Defaults to the repl naming convention:
   * "repl-<instanceId>" (matches the naming convention used elsewhere).
   */
  hostname?: string;
  /** Tailscale tags to apply on the device (e.g. ["tag:skyrepl"]). */
  tags?: string[];
}

export interface TailscaleState {
  /** Tailscale node ID (device ID). */
  deviceId: string;
  /** Primary 100.x.x.x Tailscale IP. */
  ip: string;
  /** Tailscale hostname. */
  hostname: string;
  /** Whether the device is currently online in the tailnet. */
  online: boolean;
  /** Epoch ms of last recorded tailnet contact (from Tailscale API). */
  lastSeen: number;
  /** Internal DB object ID for the device record. */
  objectId: number;
}

/** Shape stored in objects.metadata_json for type='tailscale_device'. */
interface TailscaleDeviceRecord {
  device_id: string;
  hostname: string;
  tailscale_ip: string;
  instance_id: string;
  created_at: number;
}

// =============================================================================
// Attach timeout
// =============================================================================

/** Maximum time to wait for the agent to report tailscale_status='ready'. */
const ATTACH_TIMEOUT_MS = 120_000;

/** Polling interval for heartbeat-based readiness check. */
const ATTACH_POLL_INTERVAL_MS = 2_000;

// =============================================================================
// TailscaleFeatureProvider
// =============================================================================

export class TailscaleFeatureProvider implements FeatureProvider<TailscaleConfig, TailscaleState> {
  readonly name = "tailscale";

  readonly capabilities: FeatureCapabilities = {
    requiresBootstrap: true,
    supportsHotAttach: false,
    supportsDetach: true,
    crossProvider: true,
  };

  constructor(private readonly apiClient: TailscaleApiClient) {}

  // ---------------------------------------------------------------------------
  // attach(instanceId, config)
  // ---------------------------------------------------------------------------
  //
  // 1. Create ephemeral auth key via TailscaleApiClient.createAuthKey()
  // 2. Send trigger_tailscale SSE command to agent via sseManager.sendCommand()
  // 3. Poll instance heartbeat columns for tailscale_status === "ready" (timeout 120s)
  // 4. Store device record in objects table (type='tailscale_device')
  // 5. Return TailscaleState { ip, deviceId, hostname }

  async attach(instanceId: string, config: TailscaleConfig = {}): Promise<TailscaleState> {
    const id = Number(instanceId);
    const instance = getInstance(id);
    if (!instance) {
      throw new Error(`attach: instance ${instanceId} not found`);
    }

    // Idempotency: if already ready, return existing state.
    const existing = await this.status(instanceId);
    if (existing) {
      return existing;
    }

    // Step 1: Create ephemeral auth key (or use caller-supplied one).
    const authKey = config.authKey ?? (await this._createAuthKey(instanceId, config.tags ?? []));

    // Step 2: Send trigger_tailscale SSE command to agent.
    await commandBus.sendCommand(instanceId, {
      type: "trigger_tailscale",
    });

    // Step 3: Poll instance record for tailscale_status='ready'.
    const deadline = Date.now() + ATTACH_TIMEOUT_MS;
    let tailscaleIp: string | null = null;

    while (Date.now() < deadline) {
      const current = getInstance(id);
      if (!current) {
        throw new Error(`attach: instance ${instanceId} disappeared during poll`);
      }

      if (current.tailscale_status === "ready" && current.tailscale_ip) {
        tailscaleIp = current.tailscale_ip;
        break;
      }

      if (current.tailscale_status === "failed") {
        throw new Error(
          `attach: Tailscale installation failed on instance ${instanceId}`
        );
      }

      await sleep(ATTACH_POLL_INTERVAL_MS);
    }

    if (!tailscaleIp) {
      throw new Error(
        `attach: timed out waiting for Tailscale readiness on instance ${instanceId} ` +
          `(${ATTACH_TIMEOUT_MS / 1000}s)`
      );
    }

    // Resolve device ID from tailnet by matching on IP.
    const device = await this._findDeviceByIp(tailscaleIp);
    const deviceId = device?.id ?? "";
    const hostname =
      config.hostname ??
      device?.hostname ??
      `repl-${instanceId}`;

    // Step 4: Store device record in objects table.
    const objectId = await this._storeDeviceRecord(
      instanceId,
      deviceId,
      hostname,
      tailscaleIp
    );

    // Step 5: Return state.
    return {
      deviceId,
      ip: tailscaleIp,
      hostname,
      online: device?.online ?? true,
      lastSeen: device?.lastSeen ? Date.parse(device.lastSeen) : Date.now(),
      objectId,
    };
  }

  // ---------------------------------------------------------------------------
  // detach(instanceId)
  // ---------------------------------------------------------------------------
  //
  // 1. Get device record from objects table
  // 2. Call TailscaleApiClient.deleteDevice(deviceId)
  // 3. Delete device record from objects table

  async detach(instanceId: string): Promise<void> {
    const record = this._getDeviceRecord(instanceId);
    if (!record) {
      // Nothing to detach — idempotent no-op.
      return;
    }

    const { objectId, deviceRecord } = record;

    // Delete from tailnet first; if the device is already gone, continue.
    if (deviceRecord.device_id) {
      try {
        await this.apiClient.deleteDevice(deviceRecord.device_id);
      } catch (err) {
        if (err instanceof TailscaleApiError && err.status === 404) {
          // Already removed from tailnet — proceed to clean up DB record.
        } else {
          throw err;
        }
      }
    }

    // Remove DB record.
    deleteObject(objectId);

    // Clear tailscale columns on the instance row.
    const id = Number(instanceId);
    const instance = getInstance(id);
    if (instance) {
      updateInstance(id, {
        tailscale_ip: null,
        tailscale_status: "not_installed",
      });
    }
  }

  // ---------------------------------------------------------------------------
  // status(instanceId)
  // ---------------------------------------------------------------------------
  //
  // 1. Get device record from objects table
  // 2. Call TailscaleApiClient.getDevice(deviceId) for live online status
  // 3. Return current state (or null if not installed)

  async status(instanceId: string): Promise<TailscaleState | null> {
    const record = this._getDeviceRecord(instanceId);
    if (!record) {
      return null;
    }

    const { objectId, deviceRecord } = record;

    // Refresh live status from Tailscale API.
    let online = false;
    let lastSeen = deviceRecord.created_at;
    let resolvedDeviceId = deviceRecord.device_id;
    let resolvedIp = deviceRecord.tailscale_ip;
    let resolvedHostname = deviceRecord.hostname;

    if (deviceRecord.device_id) {
      const device = await this.apiClient.getDevice(deviceRecord.device_id).catch(() => null);
      if (device) {
        online = device.online;
        lastSeen = device.lastSeen ? Date.parse(device.lastSeen) : lastSeen;
        resolvedIp = device.addresses[0] ?? resolvedIp;
        resolvedHostname = device.hostname ?? resolvedHostname;
      }
    } else {
      // No device_id recorded: check the instance columns for a live status.
      const instance = getInstance(Number(instanceId));
      if (instance?.tailscale_status === "ready" && instance.tailscale_ip) {
        online = true;
        resolvedIp = instance.tailscale_ip;
      }
    }

    return {
      deviceId: resolvedDeviceId,
      ip: resolvedIp,
      hostname: resolvedHostname,
      online,
      lastSeen,
      objectId,
    };
  }

  // ---------------------------------------------------------------------------
  // reconcile(context)
  // ---------------------------------------------------------------------------
  //
  // 1. List all devices via TailscaleApiClient.listDevices()
  // 2. Query all device records from objects table
  // 3. Find orphaned devices (in tailnet, not in DB) → log warning
  // 4. Find stale records (in DB, not in tailnet) → clean up DB
  // 5. Return ReconcileResult

  async reconcile(context: FeatureReconcileContext): Promise<ReconcileResult> {
    // Fetch live tailnet device list.
    const tailnetDevices = await this.apiClient.listDevices();
    const tailnetById = new Map<string, TailscaleDevice>(
      tailnetDevices.map((d) => [d.id, d])
    );

    // Query all tailscale_device records in DB.
    const dbRows = queryMany<{ id: number; metadata_json: string | null }>(
      "SELECT id, metadata_json FROM objects WHERE type = 'tailscale_device'"
    );

    const dbRecords: Array<{ objectId: number; record: TailscaleDeviceRecord }> = [];
    for (const row of dbRows) {
      if (!row.metadata_json) continue;
      try {
        const rec = JSON.parse(row.metadata_json) as TailscaleDeviceRecord;
        dbRecords.push({ objectId: row.id, record: rec });
      } catch {
        // Corrupted record — skip.
      }
    }

    const dbDeviceIds = new Set(dbRecords.map((r) => r.record.device_id).filter(Boolean));

    // Orphans: in tailnet but no DB record (could belong to other systems — filter by tag or name prefix).
    // We identify "ours" by checking if the device name matches the repl-* convention.
    const orphans: string[] = [];
    for (const device of tailnetDevices) {
      if (
        !dbDeviceIds.has(device.id) &&
        (device.hostname.startsWith("repl-") || device.name.startsWith("repl-"))
      ) {
        orphans.push(device.id);
        console.warn("[tailscale] orphaned device in tailnet (not in DB)", {
          deviceId: device.id,
          hostname: device.hostname,
        });
      }
    }

    // Stale records: in DB but device no longer exists in tailnet.
    const missing: string[] = [];
    for (const { objectId, record } of dbRecords) {
      if (record.device_id && !tailnetById.has(record.device_id)) {
        missing.push(record.device_id);
        // Clean up stale DB record.
        try {
          deleteObject(objectId);
        } catch (err) {
          console.warn("[tailscale] failed to delete stale device record", {
            objectId,
            deviceId: record.device_id,
            error: err instanceof Error ? err.message : String(err),
          });
        }
      }
    }

    // Also check expectedAttachments from context for drift detection.
    for (const expected of context.expectedAttachments) {
      const state = context.actualState.get(expected.instanceId);
      if (!state) {
        // Expected attachment is not reflected in actualState — already covered by stale cleanup above.
      }
    }

    return { orphans, missing };
  }

  // ---------------------------------------------------------------------------
  // Private helpers
  // ---------------------------------------------------------------------------

  /** Create an ephemeral auth key for the given instance. */
  private async _createAuthKey(instanceId: string, tags: string[]): Promise<string> {
    const result = await this.apiClient.createAuthKey({
      ephemeral: true,
      preauthorized: true,
      tags: tags.length > 0 ? tags : undefined,
      description: `skyrepl-instance-${instanceId}`,
    });
    return result.key;
  }

  /**
   * Find a Tailscale device in the tailnet by its primary IP address.
   * Returns null if no match found (e.g. not yet propagated).
   */
  private async _findDeviceByIp(ip: string): Promise<TailscaleDevice | null> {
    const devices = await this.apiClient.listDevices();
    return devices.find((d) => d.addresses.includes(ip)) ?? null;
  }

  /**
   * Store a tailscale device record in the objects table.
   * Uses object_tags for instance-scoped lookup:
   *   instance_id:<id>
   *   feature:tailscale
   *
   * The actual content is small metadata (no binary payload needed),
   * so we store it inline as a minimal blob.
   *
   * Returns the new object ID.
   */
  private async _storeDeviceRecord(
    instanceId: string,
    deviceId: string,
    hostname: string,
    tailscaleIp: string
  ): Promise<number> {
    const now = Date.now();
    const metadata: TailscaleDeviceRecord = {
      device_id: deviceId,
      hostname,
      tailscale_ip: tailscaleIp,
      instance_id: instanceId,
      created_at: now,
    };

    const payload = JSON.stringify(metadata);
    const payloadBytes = Buffer.from(payload, "utf-8");

    // Store payload as a blob (inline, <64KB).
    const blob = createBlob(
      {
        bucket: "feature-installations",
        checksum: `tailscale-${instanceId}`,
        checksum_bytes: payloadBytes.length,
        s3_key: null,
        s3_bucket: null,
        payload: payloadBytes,
        size_bytes: payloadBytes.length,
        last_referenced_at: now,
      },
      1 // tenantId: default; caller should pass tenantId when registry is wired
    );

    const obj = createObject(
      {
        type: "tailscale_device",
        blob_id: blob.id,
        provider: "tailscale",
        provider_object_id: deviceId || null,
        metadata_json: payload,
        expires_at: null,
        current_manifest_id: null,
        accessed_at: now,
        updated_at: now,
      },
      1
    );

    // Tag for fast lookup by instance.
    addObjectTag(obj.id, "instance_id", instanceId);
    addObjectTag(obj.id, "feature", "tailscale");

    return obj.id;
  }

  /**
   * Read the device record for an instance from the objects table.
   * Returns null if no record exists.
   */
  private _getDeviceRecord(
    instanceId: string
  ): { objectId: number; deviceRecord: TailscaleDeviceRecord } | null {
    // Look up via the 'instance_id:<id>' tag joined with 'feature:tailscale'.
    // The objects table has a unique constraint via object_tags, so we JOIN on both.
    const row = queryOne<{ id: number; metadata_json: string | null }>(
      `SELECT o.id, o.metadata_json
       FROM objects o
       JOIN object_tags t1 ON o.id = t1.object_id
       JOIN object_tags t2 ON o.id = t2.object_id
       WHERE o.type = 'tailscale_device'
         AND t1.tag = ?
         AND t2.tag = ?
       LIMIT 1`,
      [`instance_id:${instanceId}`, `feature:tailscale`]
    );

    if (!row || !row.metadata_json) {
      return null;
    }

    let deviceRecord: TailscaleDeviceRecord;
    try {
      deviceRecord = JSON.parse(row.metadata_json) as TailscaleDeviceRecord;
    } catch {
      return null;
    }

    return { objectId: row.id, deviceRecord };
  }
}

// =============================================================================
// Utility
// =============================================================================

function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
